// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright (C) 2026  Bartek Kus

use axiomregent::io::fs::RealFs;
use axiomregent::resolver::order::ResolveEngine;
use axiomregent::router::mounts::MountRegistry;
use axiomregent::router::{JsonRpcRequest, Router};
use axiomregent::snapshot::{lease::LeaseStore, tools::SnapshotTools};
use axiomregent::workspace::WorkspaceTools;
use serde_json::json;
use std::fs;
use std::path::PathBuf;
use std::sync::Arc;

#[test]
fn test_antigravity_verify_flow() {
    let fs = RealFs;
    let resolver = Arc::new(ResolveEngine::new(fs, Vec::<PathBuf>::new()));
    let mounts = MountRegistry::new();

    let dir = tempfile::tempdir().unwrap();
    let repo_root = dir.path().to_path_buf();

    // Init git repo for drift check
    std::process::Command::new("git")
        .arg("init")
        .current_dir(&repo_root)
        .output()
        .expect("Failed to init git");

    // Setup Storage
    let config = axiomregent::config::StorageConfig {
        data_dir: repo_root.clone(),
        blob_backend: axiomregent::config::BlobBackend::Fs,
        compression: axiomregent::config::Compression::None,
    };
    let store = Arc::new(axiomregent::snapshot::store::Store::new(config).unwrap());
    let lease_store = Arc::new(LeaseStore::new());

    let snapshot_tools = Arc::new(SnapshotTools::new(lease_store.clone(), store.clone()));
    let workspace_tools = Arc::new(WorkspaceTools::new(lease_store.clone(), store.clone()));

    let featuregraph_tools = Arc::new(axiomregent::featuregraph::tools::FeatureGraphTools::new());
    let feature_tools = Arc::new(axiomregent::feature_tools::FeatureTools::new());
    let xray_tools = Arc::new(axiomregent::xray::tools::XrayTools::new());
    let antigravity_tools = Arc::new(axiomregent::antigravity_tools::AntigravityTools::new(
        workspace_tools.clone(),
        snapshot_tools.clone(),
        feature_tools.clone(),
    ));
    let encore_tools = Arc::new(axiomregent::tools::encore_ts::tools::EncoreTools::new());
    let run_tools = Arc::new(axiomregent::run_tools::RunTools::new(&repo_root));
    let router = Router::new(
        resolver,
        mounts,
        snapshot_tools,
        workspace_tools,
        featuregraph_tools,
        xray_tools,
        antigravity_tools,
        encore_tools,
        run_tools,
    );

    // 1. Setup Repo State
    // Create spec/verification.yaml
    let spec_dir = repo_root.join("spec");
    fs::create_dir(&spec_dir).unwrap();

    let verification_yaml = r#"
version: 1
defaults:
  workdir: "."
  timeout_ms: 1000
  network: "deny"
  read_only: "tracked"
profiles:
  pr:
    include:
      - verify.test
skills:
  verify.test:
    description: "Echo test"
    determinism: "D0"
    tier: 1
    steps:
      - name: "echo"
        cmd: ["echo", "test_verify"]
        timeout_ms: 1000
    "#;
    fs::write(spec_dir.join("verification.yaml"), verification_yaml).unwrap();

    // Create Changeset
    let changeset_id = "001_verify_test";
    let changes_dir = repo_root.join("changes").join(changeset_id);
    fs::create_dir_all(&changes_dir).unwrap();

    // 05-status.json (executed)
    let status_json = json!({
        "schema_version": "v1",
        "state": "executed",
        "validation": { "state": "valid", "checks": [] },
        "execution": {
             "state": "completed",
             "steps_completed": 1,
             "error": null,
             "log": []
        }
    });
    fs::write(
        changes_dir.join("05-status.json"),
        serde_json::to_vec(&status_json).unwrap(),
    )
    .unwrap();

    // Commit all files to make repo clean
    std::process::Command::new("git")
        .args(["config", "user.email", "test@example.com"])
        .current_dir(&repo_root)
        .output()
        .expect("Failed to set user.email");
    std::process::Command::new("git")
        .args(["config", "user.name", "Test User"])
        .current_dir(&repo_root)
        .output()
        .expect("Failed to set user.name");
    std::process::Command::new("git")
        .args(["add", "."])
        .current_dir(&repo_root)
        .output()
        .expect("Failed to git add");
    std::process::Command::new("git")
        .args(["commit", "-m", "Initial"])
        .current_dir(&repo_root)
        .output()
        .expect("Failed to git commit");

    // 2. Call antigravity.verify
    let req = JsonRpcRequest {
        jsonrpc: "2.0".to_string(),
        method: "tools/call".to_string(),
        params: Some(json!({
            "name": "antigravity.verify",
            "arguments": {
                "repo_root": repo_root.to_str().unwrap(),
                "changeset_id": changeset_id,
                "profile": "pr"
            }
        })),
        id: Some(json!(1)),
    };

    let resp = router.handle_request(&req);

    // Check for error first
    if let Some(err) = &resp.error {
        panic!("Tool call failed: {:?}", err);
    }

    assert!(resp.result.is_some());
    let res = resp.result.unwrap();
    let content = &res["content"][0]["json"];
    assert_eq!(content["status"], "verified");

    // 3. Verify Artifacts
    let verify_dir = changes_dir.join("verify");
    assert!(verify_dir.exists());

    let artifact_path = verify_dir.join("verify.test.json");
    if !artifact_path.exists() {
        // Maybe name sanitization changed?
        // skill id "verify.test" -> "verify.test.json" or "verify_test.json"?
        // Code: skill_id.replace("/", "_")
        // "verify.test" -> "verify.test".
        // So it should be verify.test.json
        let files: Vec<_> = fs::read_dir(&verify_dir)
            .unwrap()
            .map(|e| e.unwrap().path())
            .collect();
        panic!(
            "Artifact verify.test.json not found in {:?}. Found: {:?}",
            verify_dir, files
        );
    }

    let artifact_bytes = fs::read(&artifact_path).unwrap();
    let artifact: serde_json::Value = serde_json::from_slice(&artifact_bytes).unwrap();

    assert_eq!(artifact["skill"], "verify.test");
    assert_eq!(artifact["summary"]["overall_exit_code"], 0);

    // Check steps
    let steps = artifact["steps"].as_array().unwrap();
    assert_eq!(steps.len(), 1);
    assert_eq!(steps[0]["name"], "echo");
    // "echo test_verify" should output "test_verify\n" ideally, but ConstrainedRunner might capture it.
    // Check stdout_preview if available (truncated/utf8).

    // 4. Verify Status Update
    let status_bytes = fs::read(changes_dir.join("05-status.json")).unwrap();
    let status: serde_json::Value = serde_json::from_slice(&status_bytes).unwrap();

    assert!(status["verification"].is_object());
    assert_eq!(status["verification"]["last_run"]["outcome"], "passed");
}
